# USB Notes

### What: my own notes from:
- https://www.beyondlogic.org/usbnutshell
- https://www.slideshare.net/macpaul/usb-specification-20-chapter-9-device-framework
- https://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_5_Errata_A.PDF
- https://wiki.osdev.org/Universal_Host_Controller_Interface
- Benjamin Lunt - The Universal Serial Bus (FYSOS)
- Universal Host Controller Interface (UHCI) Design Guide (Intel)
	

ncm, ecm, fcm, rndis. they're all just a set of data structures to send ethernet frames over usb. most of them are essentially just a set of lengths and offsets that points to ethernet frames (since you can batch ethernet frames together over USB) 


Frame: time based grouping with fixed timing

Packet: a bundle of data organized ina  group for transmission


The BUS consists on a Host and a Host Root Hub. Devices connect to the host through the Root Hub. A hub expands the number of devices a host can connect to. The host is the coordinator of all traffic so transfers are discussed relative to the host:
	- an IN Transfer means a transfer INTO the host memory
	- an OUT Transfer from the host memory to the device

<p align="center"><img src="usb/bus_topology.png" alt="drawing" width="75%"/></p>

### Device
A device is a logical or physical entity that performs one or more functions.
Hubs and peripherals are devices. The host assigns a unique address to each device on the bus. A compound device contains a hub with one or more permanently attached devices. The host treats a compound device in much the same way as if the hub and its functions were separate physical devices. The hub and embedded devices each have a unique address.

### How the PC communicates with the USB
A PC may have one or more USB controllers of a certain type or types. The controller is the actual hardware that your software communicates with to control the USB devices attached. **These controllers are often called the Root Hub.**

- Types of controllers:
   - UHCI
   - OHCI
   - EHCI
   - xHCI
   - WHCI (Wireless Host Controller Interface - used for WUSB)

Even though each controller is different and your software communicates with it differently, each controller sends the same type of USB data on the cable to the device, no matter the controller type.

### Detect Devices

On power-up, hubs make the host aware of all attached USB devices. In a process called enumeration, the host determines what bus speed to use, assigns an address, and requests additional information. After power-up, whenever a device is removed or attached, a hub informs the host of the event, and the host enumerates any newly attached device and removes any detached device from its list of devices available to applications.


The USB host controllers have their own specifications. 
	With USB 1.1, there were two Host Controller Interface Specifications:
		- UHCI (Universal Host Controller Interface) - developed by Intel which puts more of the burden on software (Microsoft)
		- OHCI (Open Host Controller Interface) developed by Compaq, Microsoft and National Semiconductor which places more of the burden on hardware(Intel) and makes for simpler software.
	
Depending on the generation of the USB technology, it is also called UHCI/OHCI for USB 1.x, EHCI for USB 2.x, and XHCI for USB 3.x controllers.


### UHCI

The UHCI consists of two parts: Host Controller Driver (HCD) and Host Controller (HC). The HCD software is
responsible for scheduling the traffic on USB by posting and maintaining transactions in system memory. HCD is
part of the system software and is typically provided by the operating system vendor. For example, Microsoft
Corporation will fully support UHCI.

The Host Controller moves data between system memory and devices on the USB by processing these data
structures and generating the transaction on USB. Note that the high transfer rates on USB means that the Host
Controller should use a high bandwidth interface to system memory. For the implementation example in this
document, the Host Controller is a PCI device. PCI Bus master capability in the Host Controller permits high
performance data transfers to system memory.

With the UHCI controller, before we set the “run” bit in the controller’s command register, we set up a page of memory, 1024 dwords, as the USB stack for this controller. Each dword points to a data structure that tells the controller what to do. These data structures tell the controller to send or receive data packets from a specified device on the bus. These data structures that the dword above points to is called a Frame with the dword called a Frame Pointer.

This controller allocates one millisecond (mS) for each frame. It follows the frame’s data structures, called Queues and Transfer Descriptors, as long as there is enough time left in the frame. Once the 1 mS has elapsed, it moves to the next frame pointer.


The UHCI specification defines a set of I/O mapped registers that allow communication between the controller and the operating system. The base address for these registers can be found by searching the PCI controller for a specific VendorID/DeviceID combination, or for a specific ClassID/SubclassID/Interface combination. All UHCI PCI controllers will have a Class ID of 0x0C, a Subclass ID of 0x03, and an Interface value of 0x00. 

The PCI Configuration space for this device will contain the I/O port address information in BAR4. 


<p align="center"><img src="usb/uhci_architecture.png" alt="drawing" width="75%"/></p>

### XHCI Architecture:

<p align="center"><img src="usb/xhci_architecture.png" alt="drawing" width="75%"/></p>



## USB Packets

USB is a host centric bus. The host initiates all transactions. The first packet, also called a token is generated by the host to describe what is to follow and whether the data transaction will be a read or write and what the device’s address and designated endpoint is. The next packet is generally a data packet carrying the payload and is followed by an handshaking packet, reporting if the data or token was received successfully, or if the endpoint is stalled or not available to accept data.

#### USB Transfer Modes:
- Control
- Interrupt
- Bulk
- Isochronous -> allows a device to reserve a defined amount of bandwidth with guaranteed latency

#### Common USB Packet Fields:

Data on the USB Bus is transmitted LSBit first. USB Packets consists of the following fields:

- **Sync**: all packets starts with a SYNC field. It is 8 bits long at low and full speed and 32bit long at high speed. It is used for synchronization purposes between the receiver and transmitter. The last two bits indicate where the PID field starts.
- **PID**: this is the Packet ID. 

<p align="center"><img src="usb/pid_values.png" alt="drawing" width="50%" height="50%"/></p>
	
- **ADDR**: The address field specifies which device the packet is designated for. Being 7 bits in length allows for 127 devices to be supported. Address 0 is not valid, as any device which is not yet assigned an address must respond to packets sent to address zero.

- **ENDP**: The endpoint field is made up of 4 bits, allowing 16 possible endpoints. Low speed devices, however can only have 2 additional endpoints on top of the default pipe. (4 endpoints max)

- **CRC**: Cyclic Redundancy Checks are performed on the data within the packet payload. All token packets have a 5 bit CRC while data packets have a 16 bit CRC.

- **EOP**: End of packet.

#### USB Packet Types

USB has four different packet types. Token packets indicate the type of transaction to follow, data packets contain the payload, handshake packets are used for acknowledging data or reporting errors and start of frame packets indicate the start of a new frame.

- **Token Packets**:
	- In - Informs the USB device that the host wishes to read information.
	- Out - Informs the USB device that the host wishes to send information.
	- Setup - Used to begin control transfers.
	  
<p align="center"><img src="usb/token_packet_format.png" title="asd" alt="" width="50%" height="50%"/></p>

- **Data Packets**: there are two types of data packets each capable of transmitting up to 1024 bytes of data.
	- Data0
	- Data1

	High Speed mode defines two data PIDs, DATA2 and MDATA.

	Data Packets have the following format:

	<p align="center"><img src="usb/data_packet_format.png" title="asd" alt="" width="50%" height="50%"/></p>

- **Handshake Packets**: There are three type of handshake packets which consist simply of the PID:
	- ACK - Acknowledgment that the packet has been successfully received.
	- NAK - Reports that the device temporary cannot send or received data. Also used during interrupt transactions to inform the host there is no data to send.
	- STALL - The device finds its in a state that it requires intervention from the host.
<p align="center"><img src="usb/handshake_packet_format.png" title="asd" alt="" width="25%" height="25%"/></p>


#### Endpoints

 Endpoints can be described as sources or sinks of data. As the bus is host centric, endpoints occur at the end of the communications channel at the USB function. Endpoints can also be seen as the interface between the hardware of the function device and the firmware running on the function device.

 All devices must support endpoint zero. This is the endpoint which receives all of the devices control and status requests during enumeration and throughout the duration while the device is operational on the bus.

#### Pipes

While the device sends and receives data on a series of endpoints, the client software transfers data through pipes. A pipe is a logical connection between the host and endpoint(s). Pipes will also have a set of parameters associated with them such as how much bandwidth is allocated to it, what transfer type (Control, Bulk, Iso or Interrupt) it uses, a direction of data flow and maximum packet/buffer sizes. For example the default pipe is a bi-directional pipe made up of endpoint zero in and endpoint zero out with a control transfer type.

USB defines two types of pipes:

- Stream Pipes have no defined USB format, that is you can send any type of data down a stream pipe and can retrieve the data out the other end. Data flows sequentially and has a pre-defined direction, either in or out. Stream pipes will support bulk, isochronous and interrupt transfer types. Stream pipes can either be controlled by the host or device.

- Message Pipes have a defined USB format. They are host controlled, which are initiated by a request sent from the host. Data is then transferred in the desired direction, dictated by the request. Therefore message pipes allow data to flow in both directions but will only support control transfers.


## Transfer Types

### Control Transfers

Control transfers are typically used for command and status operations. They are essential to set up a USB device (eg. device enumeration). 

A control transfer can have up to three stages:

1)  **Setup Stage:** three packets are sent for the setup stage.
	- Setup Token containing the address and endpoint number
	- Data packet with PID type of DATA0 and includes a SETUP_PACKET structure.
	- A handhake packet used for acknowledging successful receipt or to indicate an error.

	If the function successfully receives the setup data (CRC and PID etc OK) it responds with ACK, otherwise it ignores the data and doesn’t send a handshake packet. Functions cannot issue a STALL or NAK packet in response to a setup packet.

2) **Data Stage:** consists of one or multiple IN or OUT transfers. The setup request indicates the amount of data to be transmitted in this stage. If it exceeds the maximum packet size, data will be sent in multiple transfers each being the maximum packet length except for the last packet. The data stage has two different scenarios depending upon the direction of data transfer.

	- IN: When the host is ready to receive control data it issues an IN Token. If the function receives the IN token with an error e.g. the PID doesn't match the inverted PID bits, then it ignores the packet. If the token was received correctly, the device can either reply with a DATA packet containing the control data to be sent, a stall packet indicating the endpoint has had a error or a NAK packet indicating to the host that the endpoint is working, but temporarily has no data to send.

	- OUT: When the host needs to send the device a control data packet, it issues an OUT token followed by a data packet containing the control data as the payload. If any part of the OUT token or data packet is corrupt then the function ignores the packet. If the function's endpoint buffer was empty and it has clocked the data into the endpoint buffer it issues an ACK informing the host it has successfully received the data. If the endpoint buffer is not empty due to processing of the previous packet, then the function returns a NAK.

	<p align="center"><img src="usb/data_stage_transfer.png" title="asd" alt="" width="75%" height="75%"/></p>

3) **Status Stage:** reports the status of the overall request and this once again varies due to direction of transfer. Status reporting is always performed by the function.
	
	- IN: If the host sent IN token(s) during the data stage to receive data, then the host must acknowledge the successful recept of this data. This is done by the host sending an OUT token followed by a zero length data packet. The function can now report its status in the handshaking stage. An ACK indicates the function has completed the command is now ready to accept another command. If an error occurred during the processing of this command, then the function will issue a STALL. However if the function is still processing, it returns a NAK indicating to the host to repeat the status stage later.

	<p align="center"><img src="usb/status_stage_IN.png" title="asd" alt="" width="75%" height="75%"/></p>

	- OUT: If the host sent OUT token(s) during the data stage to transmit data, the function will acknowledge the successful recept of data by sending a zero length packet in response to an IN token. However if an error occurred, it should issue a STALL or if it is still busy processing data, it should issue a NAK asking the host to retry the status phase later.

	<p align="center"><img src="usb/status_stage_out.png" title="asd" alt="" width="75%" height="75%"/></p>

#### Example of a Control Transfer for getting a device descriptor

The host will send the Setup token telling the function that the following packet is a Setup packet. The Address field will hold the address of the device the host is requesting the descriptor from. The endpoint number should be zero, specifying the default pipe. The host will then send a DATA0 packet. This will have an 8 byte payload which is the DEVICE DESCRIPTOR Request. The USB function then acknowledges the setup packet has been read correctly with no errors. If the packet was received corrupt, the device just ignores this packet. The host will then resend the packet after a short delay.

<p align="center"><img src="usb/example_device_descriptor1.png" title="asd" alt="" width="75%" height="75%"/></p>

The above three packets represent the first USB transaction. The USB device will now decode the 8 bytes received, and determine if it was a device descriptor request. The device will then attempt to send the Device Descriptor, which will be the next USB transaction.

<p align="center"><img src="usb/example_device_descriptor2.png" title="asd" alt="" width="75%" height="75%"/></p>

In this case, we assume that the maximum payload size is 8 bytes. The host sends the IN token, telling the device it can now send data for this endpoint. As the maximum packet size is 8 bytes, we must split up the 12 byte device descriptor into chunks to send. Each chunk must be 8 bytes except for the last transaction. The host acknowledges every data packet we send it.

Once the device descriptor is sent, a status transaction follows. If the transactions were successful, the host will send a zero length packet indicating the overall transaction was successful. The function then replies to this zero length packet indicating its status.

<p align="center"><img src="usb/example_device_descriptor3.png" title="asd" alt="" width="75%" height="75%"/></p>

### Interrupt Transfers

Contrary to interrupts for other buses/devices, in USB, when the device requires attention from the host, it must wait until the hsot polls it before it can report that it needs attention.

Interrupt transfers are typically non-periodic, small "device initiated" communication. It is queued by the device until the host polls the USB device asking for data. The rate of polling is specified in the endpoint descriptor. Each poll will involve the host sending an IN Token. The function will send a data packet containing data relevant to the interrupt when it receives the IN Token.

### Isochronous Transfers

Isochronous transfers occur continuously and periodically. They typically contain time sensitive information, such as an audio or video stream. If there were a delay or retry of data in an audio stream, then you would expect some erratic audio containing glitches. The beat may no longer be in sync. However if a packet or frame was dropped every now and again, it is less likely to be noticed by the listener.

The maximum size data payload is specified in the endpoint descriptor of an Isochronous Endpoint. 

### Bulk Transfers

Bulk transfers can be used for large bursty data. Such examples could include a print-job sent to a printer or an image generated from a scanner. Bulk transfers provide error correction in the form of a CRC16 field on the data payload and error detection/re-transmission mechanisms ensuring data is transmitted and received without error.

Bulk transfers will use spare un-allocated bandwidth on the bus after all other transactions have been allocated. If the bus is busy with isochronous and/or interrupt then bulk data may slowly trickle over the bus. As a result Bulk transfers should only be used for time insensitive communication as there is no guarantee of latency.

Bulk transfers are only supported by full and high speed devices. For full speed endpoints, the maximum bulk packet size is either 8, 16, 32 or 64 bytes long. For high speed endpoints, the maximum packet size can be up to 512 bytes long.

 If the data payload falls short of the maximum packet size, it doesn't need to be padded with zeros. A bulk transfer is considered complete when it has transferred the exact amount of data requested, transferred a packet less than the maximum endpoint size, or transferred a zero-length packet.

 IN: When the host is ready to receive bulk data it issues an IN Token. If the function receives the IN token with an error, it ignores the packet. If the token was received correctly, the function can either reply with a DATA packet containing the bulk data to be sent, or a stall packet indicating the endpoint has had a error or a NAK packet indicating to the host that the endpoint is working, but temporary has no data to send.

 OUT: When the host wants to send the function a bulk data packet, it issues an OUT token followed by a data packet containing the bulk data. If any part of the OUT token or data packet is corrupt then the function ignores the packet. If the function's endpoint buffer was empty and it has clocked the data into the endpoint buffer it issues an ACK informing the host it has successfully received the data. If the endpoint buffer is not empty due to processing a previous packet, then the function returns an NAK. However if the endpoint has had an error and its halt bit has been set, it returns a STALL.

 <p align="center"><img src="usb/bulk_transfer.png" title="asd" alt="" width="75%" height="75%"/></p>

---

 ## USB Descriptors

 All USB devices have a hierarchy of descriptors which describe to the host information such as what the device is, who makes it, what version of USB it supports, how many ways it can be configured, the number of endpoints and their types etc.

 The more common USB descriptors are:
 - Device Descriptors
 - Configuration Descriptors
 - Interface Descriptors
 - Endpoint Descriptors
 - String Descriptors

 USB devices can only have one device descriptor. This descriptor includes information such as the USB revision, product and vendor Id, number of possible configurations, etc. The number of configurations indicate how many configuration descriptors branches are to follow.

 The configuration descriptor specifies values such as the amount of power this particular configuration uses, if the device is self or bus powered and the number of interfaces it has. When a device is enumerated, the host reads the device descriptors and can make a decision of which configuration to enable. It can only enable one configuration at a time. For example, It is possible to have a high power bus powered configuration and a self powered configuration. If the device is plugged into a host with a mains power supply, the device driver may choose to enable the high power bus powered configuration enabling the device to be powered without a connection to the mains, yet if it is connected to a laptop or personal organiser it could enable the 2nd configuration (self powered) requiring the user to plug your device into the power point.

 The configuration settings are not limited to power differences. Each configuration could be powered in the same way and draw the same current, yet have different interface or endpoint combinations. However it should be noted that changing the configuration requires all activity on each endpoint to stop. While USB offers this flexibility, very few devices have more than 1 configuration.

  <p align="center"><img src="usb/usb_descriptors.png" title="asd" alt="" width="100%" height="100%"/></p>

  The interface descriptor could be seen as a header or grouping of the endpoints into a functional group performing a single feature of the device. For example you could have a multi-function fax/scanner/printer device. Interface descriptor one could describe the endpoints of the fax function, Interface descriptor two the scanner function and Interface descriptor three the printer function. Unlike the configuration descriptor, there is no limitation as to having only one interface enabled at a time. A device could have 1 or many interface descriptors enabled at once.

  Interface descriptors have a bInterfaceNumber field specifying the Interface number and a bAlternateSetting which allows an interface to change settings on the fly. For example we could have a device with two interfaces, interface one and interface two. Interface one has bInterfaceNumber set to zero indicating it is the first interface descriptor and a bAlternativeSetting of zero.
  
  Interface two would have a bInterfaceNumber set to one indicating it is the second interface and a bAlternativeSetting of zero (default). We could then throw in another descriptor, also with a bInterfaceNumber set to one indicating it is the second interface, but this time setting the bAlternativeSetting to one, indicating this interface descriptor can be an alternative setting to that of the other interface descriptor two.

  This gives an advantage over having two configurations, in that we can be transmitting data over interface zero while we change the endpoint settings associated with interface one without effecting interface zero.
  
  Each endpoint descriptor is used to specify the type of transfer, direction, polling interval and maximum packet size for each endpoint. Endpoint zero, the default control endpoint is always assumed to be a control endpoint and as such never has a descriptor.

### Composition of USB Descriptors

All descriptors are made up of a common format. The first byte specifies the length of the descriptor, while the second byte indicates the descriptor type. If the length of a descriptor is smaller than what the specification defines, then the host shall ignore it. However if the size is greater than expected the host will ignore the extra bytes and start looking for the next descriptor at the end of actual length returned.

<p align="center"><img src="usb/usb_descriptor_common_fields.png" title="asd" alt="" width="100%" height="100%"/></p>

### Device Descriptor

The device descriptor of a USB device represents the entire device. As a result a USB device can only have one device descriptor. It specifies some basic, yet important information about the device such as the supported USB version, maximum packet size, vendor and product IDs and the number of possible configurations the device can have.

<p align="center"><img src="usb/device_descriptor.png" title="asd" alt="" width="100%" height="100%"/></p>

The bMaxPacketSize field reports the maximum packet size for endpoint zero. All devices must support endpoint zero.

bNumConfigurations defines the number of configurations the device supports at its current speed.

### Configuration Descriptor

A USB device can have several different configurations although the majority of devices are simple and only have one. The configuration descriptor specifies how the device is powered, what the maximum power consumption is, the number of interfaces it has. Therefore it is possible to have two configurations, one for when the device is bus powered and another when it is mains powered. As this is a "header" to the Interface descriptors, its also feasible to have one configuration using a different transfer mode to that of another configuration.

<p align="center"><img src="usb/configuration_descriptor.png" title="asd" alt="" width="100%" height="100%"/></p>

### Interface Descriptor

The interface descriptor could be seen as a header or grouping of the endpoints into a functional group performing a single feature of the device.

<p align="center"><img src="usb/interface_descriptor.png" title="asd" alt="" width="100%" height="100%"/></p>

- bInterfaceNumber indicates the index of the interface descriptor. This should be zero based, and incremented once for each new interface descriptor.

- bAlternativeSetting can be used to specify alternative interfaces. These alternative interfaces can be selected with the Set Interface request.

- bNumEndpoints indicates the number of endpoints used by the interface. This value should exclude endpoint zero and is used to indicate the number of endpoint descriptors to follow.

- bInterfaceClass, bInterfaceSubClass and bInterfaceProtocol can be used to specify supported classes (e.g. HID, communications, mass storage etc.) This allows many devices to use class drivers preventing the need to write specific drivers for your device.

- iInterface allows for a string description of the interface.

### Endpoint Descriptor

Endpoint descriptors are used to describe endpoints other than endpoint zero. Endpoint zero is always assumed to be a control endpoint and is configured before any descriptors are even requested. The host will use the information returned from these descriptors to determine the bandwidth requirements of the bus.

<p align="center"><img src="usb/endpoint_descriptor.png" title="asd" alt="" width="100%" height="100%"/></p>

- bEndpointAddress indicates what endpoint this descriptor is describing.

- bmAttributes specifies the transfer type. This can either be Control, Interrupt, Isochronous or Bulk Transfers. If an Isochronous endpoint is specified, additional attributes can be selected such as the Synchronisation and usage types.

- wMaxPacketSize indicates the maximum payload size for this endpoint.

- bInterval is used to specify the polling interval of certain transfers. The units are expressed in frames, thus this equates to either 1ms for low/full speed devices and 125us for high speed devices.

### String Descriptors

String descriptors provide human readable information and are optional. If they are not used, any string index fields of descriptors must be set to zero indicating there is no string descriptor available.

String Index 0 should return a list of supported languages:

The above String Descriptor shows the format of String Descriptor Zero. The host should read this descriptor to determine what languages are available. If a language is supported, it can then be referenced by sending the language ID in the wIndex field of a Get Descriptor(String) request.

<p align="center"><img src="usb/string_descriptor_1.png" title="asd" alt="" width="100%" height="100%"/></p>

All subsequent strings take on the format below,

<p align="center"><img src="usb/string_descriptor_2.png" title="asd" alt="" width="100%" height="100%"/></p>

---

## USB Requests

### Setup Packet

Every USB device must respond to setup packets on the default pipe. These are used for detection and configuration of the device and carry out common functions such as setting the USB device's address, requesting a device descriptor or checking the status of an endpoint.

A USB compliant host expects all requests to be processed within a maximum period of 5 seconds. 

Each request starts with a 8 byte long Setup Packet which has the following format:

<p align="center"><img src="usb/usb_request_common_fields.png" title="asd" alt="" width="100%" height="100%"/></p>

The bmRequestType field will determine the direction of the request, type of request and designated recipient. The bRequest field determines the request being made. The bmRequestType is normally parsed and execution is branched to a number of handlers such as a Standard Device request handler, a Standard Interface request handler, a Standard Endpoint request handler, a Class Device request handler etc.

*Standard requests are common to all USB devices.* 

*Class requests are common to classes of drivers. For example, all device conforming to the HID class will have a common set of class specific requests. These will differ to a device conforming to the communications class and differ again to that of a device conforming to the mass storage class.*

*And last of all are the vendor defined requests. These are requests which you as the USB device designer can assign. These are normally different from device to device, but this is all up to your implementation and imagination.*

### Standard Device Requests

<p align="center"><img src="usb/standard_device_requests.png" title="asd" alt="" width="100%" height="100%"/></p>

---
---

## EFI USB I/O 

If a platform includes USB bus support, then the EFI_USB2_HC_PROTOCOL and the EFI_USB_IO_PROTOCOL must be implemented. An external device can support USB by producing a USB Host Controller Protocol.

EFI_USB_IO_PROTOCOL --> Protocol interfaces to abstract access to a USB controller.

EFI_USB2_HC_PROTOCOL --> Protocol interfaces to abstract access to a USB Host
Controller.

### Hot-Plug Events

In the past, system firmware has not had to deal with hot-plug events in the preboot environment. However, with the advent of buses like USB, where the end user can add and remove devices at any time, it is important to make sure that it is possible to describe these types of buses in the UEFI Driver Model. It is up to the bus driver of a bus that supports the hot adding and removing of devices to provide support for such events. For these types of buses, some of the platform management is going to have to move into the bus drivers. For example, when a keyboard is hot added to a USB bus on a platform, the end user would expect the keyboard to be active. A USB Bus driver could detect the hot-add event and create a child handle for the keyboard device. However, because drivers are not connected to controllers unless EFI_BOOT_SERVICES.ConnectController() is called,
the keyboard would not become an active input device. Making the keyboard driver active requires the USB Bus driver to call ConnectController() when a hot-add event occurs. In addition,
the USB Bus Driver would have to call EFI_BOOT_SERVICES.DisconnectController()when a hot-remove event occurs. If EFI_BOOT_SERVICES.DisconnectController() returns an error the USB Bus Driver needs to retry the EFI_BOOT_SERVICES.DisconnectController() from a timer event until it succeeds. 

### USB Bus Driver
USB Bus Driver performs periodic Enumeration on the USB Bus. In USB bus enumeration, when a new USB controller is found, the bus driver does some standard configuration for that new controller, and creates a device handle for it. The EFI_USB_IO_PROTOCOL and the EFI_DEVICE_PATH_PROTOCOL are attached to the device handle so that the USB controller can be accessed. The USB Bus Driver is also responsible for connecting USB device drivers to USB controllers. When a USB device is detached from a USB bus, the USB bus driver will stop that USB controller, and uninstall the EFI_USB_IO_PROTOCOL and the
EFI_DEVICE_PATH_PROTOCOL from that handle. 

### USB Bus Enumeration


When the periodic timer or the hubs notify event is signaled, the USB Bus Driver will perform bus numeration.

If the connection is on the root hub, which is the PCI card on the motherboard, the reset is sent via the controller’s hardware. If the connection is on an external
hub, the host sends a reset packet to the hub in uestion. A port reset is different on different controller types.

Once the reset has completed, the host starts the enumeration process. This process is determined by the host software’s developers and may be done differently depending on the wants of the developers. Usually, you want to get as little information as you need, then move
the device to the addressed state before you continue on with the enumeration. However, it is perfectly legal to do most standard enumeration requests while the device is in the default state.

Normally we will get the first few bytes of the device descriptor, reset the port, set the device to the address state, giving it an address of one or higher, then continuing to request the rest of the device’s descriptors including getting the complete initial device
descriptor. One of these descriptors will be the endpoint descriptor. A device may have more than one, while normally a standard device will not have more than three: the default endpoint, for control transfers; an in endpoint and an out endpoint. 

Each device must have at least one configuration descriptor. After choosing which one, we then have to set that configuration. The device is now ready for use.


Steps:

1. Determine if the event is from the root hub or a standard USB hub.
2. Determine the port on which the connection change event occurred.
3. Determine if it is a connection change or a disconnection change.
4. If a connect change is detected, then a new device has been attached. Perform the following:
	- Reset and enable that port.
	- Configure the new device.
	- Parse the device configuration descriptors; get all of its interface descriptors (i.e., all USB controllers), and configure each interface.
	- Create a new handle for each interface (USB Controller) within the USB device. Attach the EFI_DEVICE_PATH_PROTOCOL, and the EFI_USB_IO_PROTOCOL to each handle.
	- Connect the USB Controller to a USB device driver with the Boot Service EFI_BOOT_SERVICES.ConnectController() if applicable.
	- If the USB Controller is a USB hub, create a Hub notify event which is associated with the USB Bus Enumerator, and submit an Asynchronous Interrupt Transfer Request.
5. If a disconnect change, then a device has been detached from the USB Bus. Perform the following:
	- If the device is not a USB Hub, then find and deconfigure the USB Controllers within the device. Then, stop each USB controller with EFI_BOOT_SERVICES.DisconnectController(), and uninstall the EFI_DEVICE_PATH_PROTOCOL and the EFI_USB_IO_PROTOCOL from the controller’s handle. If the EFI_BOOT_SERVICES.DisconnectController() call fails this process must be retried on a subsequent timer tick.
	- If the USB controller is USB hub controller, first find and deconfigure all its downstream USB devices (this is a recursive process, since there may be additional USB hub controllerson the downstream ports), then deconfigure USB hub controller itself.

### USB Device Driver
A USB Device Driver manages a USB Controller and produces a device abstraction for use by a preboot application. 


### USB I/O Protocol

This section provides a detailed description of the EFI_USB_IO_PROTOCOL. This protocol is used by code, typically drivers, running in the EFI boot services environment to access USB devices like USB keyboards, mice and mass storage devices. In particular, functions for managing devices on USB buses are defined here.

The interfaces provided in the EFI_USB_IO_PROTOCOL are for performing basic operations to access USB devices.

```c
#define EFI_USB_IO_PROTOCOL_GUID \
 {0x2B2F68D6,0x0CD2,0x44cf, {0x8E,0x8B,0xBB,0xA2,0x0B,0x1B,0x5B,0x75}}

typedef struct _EFI_USB_IO_PROTOCOL {
	EFI_USB_IO_CONTROL_TRANSFER UsbControlTransfer;
	EFI_USB_IO_BULK_TRANSFER UsbBulkTransfer;
	EFI_USB_IO_ASYNC_INTERRUPT_TRANSFER	UsbAsyncInterruptTransfer;
	EFI_USB_IO_SYNC_INTERRPUT_TRANSFER UsbSyncInterruptTransfer
	EFI_USB_IO_ISOCHRONOUS_TRANSFER UsbIsochronousTransfer;
	EFI_USB_IO_ASYNC_ISOCHRONOUS_TRANSFER UsbAsyncIsochronousTransfer;
	EFI_USB_IO_GET_DEVICE_DESCRIPTOR UsbGetDeviceDescriptor;
	EFI_USB_IO_GET_CONFIG_DESCRIPTOR UsbGetConfigDescriptor;
	EFI_USB_IO_GET_INTERFACE_DESCRIPTOR UsbGetInterfaceDescriptor;
	EFI_USB_IO_GET_ENDPOINT_DESCRIPTOR UsbGetEndpointDescriptor;
	EFI_USB_IO_GET_STRING_DESCRIPTOR UsbGetStringDescriptor;
	EFI_USB_IO_GET_SUPPORTED_LANGUAGES UsbGetSupportedLanguages;
	EFI_USB_IO_PORT_RESET UsbPortReset;
} EFI_USB_IO_PROTOCOL;

// FROM iPXE usbio.c

/** @file
 *
 * EFI_USB_IO_PROTOCOL pseudo Host Controller Interface driver
 *
 *
 * The EFI_USB_IO_PROTOCOL is an almost unbelievably poorly designed
 * abstraction of a USB device.  It would be just about forgivable for
 * an API to support only synchronous operation for bulk OUT
 * endpoints.  It is imbecilic to support only synchronous operation
 * for bulk IN endpoints.  This apparently intern-designed API
 * throttles a typical NIC down to 1.5% of its maximum throughput.
 * That isn't a typo.  It really is that slow.
 *
 * We can't even work around this stupidity by talking to the host
 * controller abstraction directly, because an identical limitation
 * exists in the EFI_USB2_HC_PROTOCOL.
 *
 * Unless you derive therapeutic value from watching download progress
 * indicators lethargically creep through every single integer from 0
 * to 100, you should use iPXE's native USB host controller drivers
 * instead.  (Or just upgrade from UEFI to "legacy" BIOS, which will
 * produce a similar speed increase.)
 *
 *
 * For added excitement, the EFI_USB_IO_PROTOCOL makes the
 * (demonstrably incorrect) assumption that a USB driver needs to
 * attach to exactly one interface within a USB device, and provides a
 * helper method to retrieve "the" interface descriptor.  Since pretty
 * much every USB network device requires binding to a pair of
 * control+data interfaces, this aspect of EFI_USB_IO_PROTOCOL is of
 * no use to us.
 *
 * We have our own existing code for reading USB descriptors, so we
 * don't actually care that the UsbGetInterfaceDescriptor() method
 * provided by EFI_USB_IO_PROTOCOL is useless for network devices.  We
 * can read the descriptors ourselves (via UsbControlTransfer()) and
 * get all of the information we need this way.  We can even work
 * around the fact that EFI_USB_IO_PROTOCOL provides separate handles
 * for each of the two interfaces comprising our network device.
 *
 * However, if we discover that we need to select an alternative
 * device configuration (e.g. for devices exposing both RNDIS and
 * ECM), then all hell breaks loose.  EFI_USB_IO_PROTOCOL starts to
 * panic because its cached interface and endpoint descriptors will no
 * longer be valid.  As mentioned above, the cached descriptors are
 * useless for network devices anyway so we _really_ don't care about
 * this, but EFI_USB_IO_PROTOCOL certainly cares.  It prints out a
 * manic warning message containing no fewer than six exclamation
 * marks and then literally commits seppuku in the middle of the
 * UsbControlTransfer() method by attempting to uninstall itself.
 * Quite how the caller is supposed to react when asked to stop using
 * the EFI_USB_IO_PROTOCOL instance while in the middle of an
 * uninterruptible call to said instance is left as an exercise for
 * the interested reader.
 *
 * There is no sensible way to work around this, so we just
 * preemptively fail if asked to change the device configuration, on
 * the basis that reporting a sarcastic error message is often
 * preferable to jumping through a NULL pointer and crashing the
 * system.
 */
```